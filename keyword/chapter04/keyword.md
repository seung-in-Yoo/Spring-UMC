## 🎯핵심 키워드

---

## DI
DI(Dependency Injection): 의존성 주입

의존성이란? 어떤 객체가 다른 객체를 필요로 할 때, 그 필요한 객체를 **의존 객체라고 함.**

**의존성 주입**은 필요한 객체(의존성)를 **직접 생성하지 않고**, **외부에서 주입**받는 방식이다.

간단하게 말하면 클래스 A가 클래스 B를 사용할 때, A가 B를 직접 new를 사용해서 생성하지 않고,**스프링이 대신 만들어서 A에 넣어주는 것**

그렇다면 DI는 왜 사용해야하는것일까?

우선 DI를 사용하지않고 객체를 직접 생성하게 된다면 결합도가 높은 코드가 완성되게 된다. 이러한 높은 결합도는 자바의  유연하고 확장 가능한 시스템을 설계하는게 어려움을 주고 결론적으로 유지보수를 하는것도 크게 어려워지게 된다. 또한 DI를 통해서 **객체 생성**과 **비즈니스 로직 처리**를 분리할 수 있다.

객체 생성은 **스프링 컨테이너**가 맡고, 우리는 **비즈니스 로직 구현**에 집중하도록 설계가 가능해진다.

하지만 이런 DI에도 단점은 존재함.

| 단점                  | 설명 |
|-----------------------|------|
| 초기 학습 비용         | DI와 IoC 컨테이너의 개념이 생소하고 추상적이어서 처음 배우는 사람에겐 이해가 어려울 수 있음. |
| 복잡성 증가            | 프로젝트 규모가 커질수록 Bean 설정, 의존성 관리가 복잡해지고 전체 구조 파악이 어려워질 수 있음. |
| 디버깅 어려움          | 스프링이 객체를 자동으로 주입하기 때문에, 런타임 시 문제가 발생하면 원인을 추적하기 어려운 경우가 있음. |
| 생성 순서 제어 어려움  | 부적절한 DI 설계로 인해 순환 참조 문제(A가 B를, B가 A를 참조)가 발생할 수 있으며, 해결이 까다로울 수 있음. |

DI의 종류:

1. **생성자 주입(Constructor Injection)**  (대부분 사용)
2. **세터 주입(Setter Injection)**
3. **필드 주입(Field Injection)**

이렇게 글로만 보면 DI 자체의 개념이 나 또한 헷갈려서 아주 간단한 코드의 예시로 DI를 이해해보겠다.

```java
public class Car {
    private Engine engine = new Engine();  // 직접 생성
}
```
현재 Car 클래스에 Engine이라는 객체를 생성했는데 이렇게 코드를 짜게되면 Car는 Engine에 강한 상태로 결합되게 되어 Engine을 테스트나 교체하기가 어려워진다. 또한 이렇게 다른 종류의 Engine을 넣고 싶을 때 코드 수정이 필요함.

```java
public class Car {
    private Engine engine;

    public Car(Engine engine) {
        this.engine = engine;
    }
}
```
아까와 다르게 `Car`는 `Engine`에 대해 잘 모르고도 동작 가능. 그리고 다양한 `Engine` 객체를 바꿔끼우기 쉬워지며 그로인해 테스트가 쉬워진다

결론적으로 → 유지보수, 확장에 유리함.

## IoC
**IoC는 객체의 생성, 연결, 생명 주기를 개발자가 직접 제어하지 않고, 프레임워크(스프링 등)가 대신 제어하게 하는 개념**이다.

간단하게 말하면 제어권을 개발자가 아닌 스프링에게 넘겨주는것

```java
public class App {
    public static void main(String[] args) {
        Engine engine = new GasEngine();   // 객체 생성
        Car car = new Car(engine);        // 의존성 주입
        car.drive();                      
    }
}
```

```java
@Component
public class GasEngine implements Engine {
    @Override
    public void start() {
        System.out.println("가스 엔진");
    }
}

@Component
public class Car {
    private final Engine engine;

    @Autowired
    public Car(Engine engine) {
        this.engine = engine;
    }

    public void drive() {
        engine.start();
    }
}

```
코드를 비교하면 밑에 코드는 개발자는 Car가 Engine을 필요로 한다는 것만 표현해주고, 객체 생성과 필요한 의존성도 모두 스프링이 알아서 넣어주도록 한다.

### IoC를 실현하는 주체: Spring Container (스프링 컨테이너)

- 스프링은 컨테이너로 IoC를 실현시킴
- 컨테이너의 역할은:
    - 객체(Bean)를 생성
    - 객체들 간의 의존관계를 설정
    - 객체 생명주기 관리 (초기화, 소멸 등)

IoC를 사용하기 이전에는 다음과 순서로 객체가 만들어지고 실행되었다.

1. 객체 생성
2. 의존성 객체 생성

   *클래스 내부에서 생성*

3. 의존성 객체 메소드 호출

하지만, 스프링에서는 다음과 같은 순서로 객체가 만들어지고 실행된다.

1. 객체 생성
2. 의존성 객체 주입

   *스스로가 만드는것이 아니라 제어권을 **스프링에게 위임하여 스프링이 만들어놓은 객체를 주입**한다.*

3. 의존성 객체 메소드 호출

**스프링이 모든 의존성 객체를 스프링이 실행될때 다 만들어주고 필요한곳에 주입**시켜줌으로써 **Bean들은 `싱글턴 패턴`의 특징**을 가지며,

**제어의 흐름을 사용자가 컨트롤 하는 것이 아니라 스프링에게 맡겨 작업을 처리**하게 된다.
이런 IoC를 사용하는 목적으로는 

| 목적 / 장점             | 설명 |
|--------------------------|------|
| 관심사의 분리 (SoC)       | 객체 생성과 비즈니스 로직 수행을 분리하여 코드의 역할을 명확히 나눔. |
| 유지보수성 증가          | 객체 생성 방식이 변경되어도 비즈니스 로직에는 영향을 주지 않아 수정이 쉬움. |
| 유연성                   | 인터페이스를 기준으로 다양한 구현체를 자유롭게 교체할 수 있어 확장에 용이함. |
| 테스트 용이성            | 테스트 시 필요한 객체(Mock 등)를 외부에서 쉽게 주입할 수 있어 단위 테스트 작성이 수월함. |

등이 있다.

```java
@Controller
public class HelloController {
    @GetMapping("/hello")
    public String hello() {
        return "hello";  // 요청이 들어오면 스프링이 이 메서드를 호출함
    }
}
```

이 메서드를 개발자가 직접 호출하지 않고 Spring 프레임워크가 자동으로 요청을 받아서 흐름을 관리하고 호출하는데, 이게 바로 IoC로, IoC는 프레임워크의 핵심적인 특징이다.

## 프레임워크와 API의 차이
우선 둘의 차이를 알아보기 전에 각각의 개념이 뭔지 살펴본다면

프레임워크:  **특정 목적의 프로그램을 만들기 위해 미리 구성된 코드 구조(뼈대)**

- 개발자가 코드를 짜는 방식 자체를 **정해진 틀 안에서 하도록 유도**
- 기능도 제공하고, **흐름 제어도 담당**함
- 예: Spring, Django, React, Angular, Flutter

즉, **"이 틀 안에서 너가 알맞게 조립해"라는 개발 구조 제공자**

API: **어떤 프로그램이 제공하는 기능을 외부에서 사용할 수 있도록 만든 "인터페이스"**

- 라이브러리의 함수나 클래스를 외부에서 호출할 수 있도록 해주는 **명세 또는 약속**
- 예: 자바의 `Math.random()`, 자바스크립트의 `fetch()`, Android SDK의 `LocationManager`, Spring의 `RestTemplate`

즉, **"이 기능 써도 돼" 하고 공개된 사용 설명서**

이렇게 개념만 봐서는 확실한 둘의 차이를 알아보기 힘들수도 있는데 그렇다면 이 둘의 확실한 차이점을 알수 있는것은? 가장 큰 차이점은 **흐름의 제어권에 있다.**

| 항목     | API                                | Framework                                  |
|----------|-------------------------------------|---------------------------------------------|
| 제어권   | 개발자가 직접 함수나 메서드를 호출하여 제어함 | 프레임워크가 전체 흐름을 제어하고, 개발자의 코드를 필요할 때 호출함 (Inversion of Control) |
| 흐름     | 개발자가 원하는 시점에 명시적으로 호출하여 동작시킴 | 개발자는 정해진 규칙에 따라 작성만 하면, 프레임워크가 자동으로 실행 흐름을 관리함 |

또한 이런 API와 프레임워크는 목적에 따른 차이도 존재하는데, API의 주 목적은 API를 통해 어떠한 기능을 사용하게 하는것이고, 프레임워크는 프로그램을 **구조적으로 만들게** 함이다.

예시를 들어보면 현재 공부하고 있는 프레임워크인 스프링과 내가 예전에 자주 사용했던 Kakao Login API를 예시로 차이를 알아보면

### Spring (Framework)

- 웹 애플리케이션을 만들기 위한 **구조와 흐름을 제공**
- 컨트롤러, 서비스, 리포지토리 구조 따름
- IoC/DI로 객체 관리까지 해줌

### Kakao Login API (API)

- 로그인 기능을 외부에 공개한 인터페이스
- 사용자는 액세스 토큰을 보내 로그인 정보를 얻음
- 프레임워크가 아니다→ 이것은 기능만 제공하고, 전체 앱 구조에는 관여 안 함

## AOP
- AOP는 aspect-oriented programming의 약자로 관점 지향 프로그래밍이라고도 말한다.
- AOP는 프로그램 구조에 대한 또 다른 사고 방식을 제공하여 객체 지향 프로그래밍(OOP)을 보완한다. OOP에서 모듈화의 핵심 단위가 "클래스"라고 한다면, AOP에서는 핵심 단위가 "관점"이다.
- 반복되고 공통적으로 사용되는 부분을 **분리**함으로써 모듈성을 증가시키는 프로그래밍 방법이다.

쉽게 말해 ⇒ 관점을 기준으로 묶어 개발하는 방식!!

(관점: 어떤 기능을 구현할 때 그 기능을 '핵심 기능' 과 '부가 기능'으로 구분해 각각 하나의 관점으로 보는 것)

### 그렇다면 이런 AOP는 왜 필요한건가?

우리는 대부분의 애플리케이션에서 여러 공통 기능을 여러 클래스에서 반복적으로 사용하는데,

- 로깅 (Logging)
- 트랜잭션 처리
- 보안 검사
- 성능 측정
- 예외 처리

이걸 각 서비스 로직에 일일이 넣는다면?

1. 코드가 **지저분해지고**, 유지보수가 어려워짐
2. **중복 코드가 생기고**, 핵심 로직이 흐려짐

하지만  AOP는 이런 **반복되는 공통 로직**을 한 곳에 모아서,필요한 곳에만 **자동으로 끼워넣을 수 있게** 해준다.

**AOP에는 핵심 용어들이 존재**하는데 이건 나도 아직 잘 몰라서 용어 적어놓고 이해해보기

| 용어            | 설명 |
|------------------|------|
| Aspect           | 공통 관심사를 모듈화한 클래스 (예: 로깅, 보안, 트랜잭션 등) |
| Join Point       | Aspect가 적용될 수 있는 지점 (예: 메서드 호출, 예외 발생 시점 등) |
| Advice           | 실제로 수행될 공통 기능 (예: 메서드 실행 전/후에 로그 출력) |
| Pointcut         | Advice가 어느 Join Point에 적용될지를 결정하는 조건 또는 표현식 |
| Weaving          | Advice를 실제 코드에 적용(결합)하는 과정 (컴파일 시, 클래스 로딩 시, 런타임 중 가능) |
| Target Object    | Advice가 적용될 실제 객체 (비즈니스 로직이 들어있는 클래스) |
| Proxy            | 스프링이 만든 가짜 객체로, Target 객체를 감싸고 Advice를 함께 실행시켜주는 래퍼 객체 |

### 스프링에서 AOP의 동작 방법 및 구현 방식

핵심은 **프록시 기반 AOP**

- Spring은 대상 객체의 **프록시 객체를 생성**
- 메서드가 호출될 때 **프록시가 가로채서 Advice 실행 → 원래 메서드 호출**

기본적으로 스프링은 JDK 동적 프록시 또는 CGLIB 프록시를 이용해 AOP 구현한다고 함

간단하게 스프링 AOP의 구현 방법을 살펴본다면

1. 의존성 추가 (Spring Boot 사용 시 자동 포함됨)
2. `@Aspect`어노테이션으로 클래스 정의
3. `@Before`, `@After`, `@Around` 등의 Advice 설정
4. `@EnableAspectJAutoProxy` 로 AOP 활성화 (Spring Boot는 자동 설정)

### 그렇다면 AOP의 장단점은?

**장점**

- 공통 로직을 분리하여 **코드 간결성, 가독성 증가**
- 관심사 분리 (SoC, Separation of Concerns) 실현
- 중복 제거 및 유지보수 용이

**단점**

- 처음엔 개념이 복잡할 수 있음 (프록시, Join Point, Pointcut 등)
- 디버깅 시 흐름 파악이 어려워질 수 있음 (자동으로 끼워넣기 때문에)

## 서블릿
서블릿의 정의

: 클라이언트의 요청을 처리하고 그 결과를 반환하는 기술

- 동적 웹페이지 서버에서 수행되는 소형 프로그램
- 각 사용자의 요청이 서버의 하나의 스레드로 수행된다. '자바 서블릿'은 자바를 사용해 웹 페이지를 동적으로 생성하는 서버내 프로그램이라고 한다.
- JSP와 달리 자바코드 안에 HTMl을 포함하고 있다는 점이 다름. (JSP는 Html에 자바 코드 포함)

⇒  자바 진영의 웹 서버에서 **요청-응답을 처리하는 핵심 컴포넌트**

로그인 페이지를 예를들어 설명해보면

- Http Request에 사용자의 Id/Password가 들어간다면
- Http Response로는 로그인 후 페이지를 보내야 한다.
- 사용자의 로그인 정보를 받아 확인후, 다음 페이지를 보내는 프로그램이 바로 ***서블릿***
- 웹서버는 요청을 WAS(웹 어플리케이션서버)에게 넘기고, WAS는 요청에 따른 서블릿을 실행한다. 서블릿은 요청에 대한 응답을 클라이언트에게 보냄.

### 서블릿의 특징은?

- 웹 서버가 동적인 페이지를 제공할 수 있도록 돕는다.
- html을 사용하여 요청에 응답한다.
- Java Thread를 이용하여 동작한다.
- MVC 패턴에서 Controller로 이용된다.
- HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다.
- UDP보다 처리 속도가 느리다.
- HTML 변경 시 Servlet을 재컴파일해야 하는 단점이 있다.
- 서블릿은 서블릿 컨테이너에서 관리된다.(new 로 생성되지 않으며, main()이 없다)

서블릿은 라이프사이클을 가지고 있는데,

서블릿은 단순히 메서드를 실행하는 것 이상의 **생명 주기(lifecycle)** 를 가진다.

| 단계        | 설명 |
|-------------|------|
| `init()`     | 서블릿이 처음 생성될 때 딱 한 번 호출됨. 주로 초기 설정이나 리소스 로딩에 사용됨. |
| `service()`  | 클라이언트 요청이 들어올 때마다 호출됨. 요청 방식에 따라 `doGet()`, `doPost()` 등이 실행됨. |
| `destroy()`  | 서버가 종료되거나 해당 서블릿이 제거될 때 호출됨. 리소스 정리나 종료 작업에 사용됨. |

이 구조는 **Tomcat** 같은 웹 서버가 관리

### 스프링에서 서블릿의 작동하는걸 예시로 살펴보기
```java
@RestController
public class HelloController {
    @GetMapping("/hello")
    public String hello(@RequestParam String name) {
        return "Hello, " + name;
    }
}
```

1. 브라우저가 `/hello?name=철수` 요청
2. 내부적으로는 `DispatcherServlet`이 이 요청을 받아
3. 해당 메서드를 찾아 실행하고
4. 응답 문자열을 `HttpServletResponse`로 반환함

⇒ 서블릿이란 단어는 안 쓰이지만, **사실 내부에선 서블릿이 계속 작동**